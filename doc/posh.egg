(*  NOTE NOTE NOTE  This grammar needs whitespace handling *)
                         (* Version 1.0 *)
                         (* 2014/09/29  *)

                     (*                     *)
                     (* ASCII character set *)
                     (*                     *)

nul =               /0x00/ ;    (* NUL *)
soh =               /0x01/ ;    (* SOH (start of heading) *)
stx =               /0x02/ ;    (* STX (start of text) *)
etx =               /0x03/ ;    (* ETX (end of text) *)
eot =               /0x04/ ;    (* EOT (end of transmission) *)
enq =               /0x05/ ;    (* ENQ (enquiry) *)
ack =               /0x06/ ;    (* ACK (acknowledge) *)
bel =               /0x07/ ;    (* BEL (bell) *)
bs =                /0x08/ ;    (* BS  (backspace) *)
ht =                /0x09/ ;    (* HT  (horizontal tab) *)
lf =                /0x0A/ ;    (* LF  (new line) *)
vt =                /0x0B/ ;    (* VT  (vertical tab) *)
ff =                /0x0C/ ;    (* FF  (form feed) *)
cr =                /0x0D/ ;    (* CR  (carriage ret) *)
so =                /0x0E/ ;    (* SO  (shift out) *)
si =                /0x0F/ ;    (* SI  (shift in) *)
dle =               /0x10/ ;    (* DLE (data link escape) *)
dc1 =               /0x11/ ;    (* DC1 (device control 1) *)
dc2 =               /0x12/ ;    (* DC2 (device control 2) *)
dc3 =               /0x13/ ;    (* DC3 (device control 3) *)
dc4 =               /0x14/ ;    (* DC4 (device control 4) *)
nak =               /0x15/ ;    (* NAK (negative ack.) *)
syn =               /0x16/ ;    (* SYN (synchronous idle) *)
etb =               /0x17/ ;    (* ETB (end of trans. blk) *)
can =               /0x18/ ;    (* CAN (cancel) *)
em =                /0x19/ ;    (* EM  (end of medium) *)
sub =               /0x1A/ ;    (* SUB (substitute) *)
esc =               /0x1B/ ;    (* ESC (escape) *)
fs =                /0x1C/ ;    (* FS  (file separator) *)
gs =                /0x1D/ ;    (* GS  (group separator) *)
rs =                /0x1E/ ;    (* RS  (record separator) *)
us =                /0x1F/ ;    (* US  (unit separator) *)
space =             /0x20/ ;    (* SPACE *)
exclamation-point = /0x21/ ;    (* ! *)
quote =             /0x22/ ;    (* " *)
number-sign =       /0x23/ ;    (* # *)
dollar =            /0x24/ ;    (* $ *)
percent =           /0x25/ ;    (* % *)
ampersand =         /0x26/ ;    (* & *)
single-quote =      /0x27/ ;    (* ' *)
open-parenthesis =  /0x28/ ;    (* ( *)
close-parenthesis = /0x29/ ;    (* ) *)
asterisk =          /0x2A/ ;    (* * *)
plus =              /0x2B/ ;    (* + *)
comma =             /0x2C/ ;    (* , *)
minus =             /0x2D/ ;    (* - *)
period =            /0x2E/ ;    (* . *)
slash =             /0x2F/ ;    (* / *)
zero =              /0x30/ ;    (* 0 *)
one =               /0x31/ ;    (* 1 *)
two =               /0x32/ ;    (* 2 *)
three =             /0x33/ ;    (* 3 *)
four =              /0x34/ ;    (* 4 *)
five =              /0x35/ ;    (* 5 *)
six =               /0x36/ ;    (* 6 *)
seven =             /0x37/ ;    (* 7 *)
eight =             /0x38/ ;    (* 8 *)
nine =              /0x39/ ;    (* 9 *)
colon =             /0x3A/ ;    (* : *)
semicolon =         /0x3B/ ;    (* ; *)
less-than =         /0x3C/ ;    (* < *)
equal =             /0x3D/ ;    (* = *)
greater-than =      /0x3E/ ;    (* > *)
question-mark =     /0x3F/ ;    (* ? *)
at =                /0x40/ ;    (* @ *)
A =                 /0x41/ ;    (* A *)
B =                 /0x42/ ;    (* B *)
C =                 /0x43/ ;    (* C *)
D =                 /0x44/ ;    (* D *)
E =                 /0x45/ ;    (* E *)
F =                 /0x46/ ;    (* F *)
G =                 /0x47/ ;    (* G *)
H =                 /0x48/ ;    (* H *)
I =                 /0x49/ ;    (* I *)
J =                 /0x4A/ ;    (* J *)
K =                 /0x4B/ ;    (* K *)
L =                 /0x4C/ ;    (* L *)
M =                 /0x4D/ ;    (* M *)
N =                 /0x4E/ ;    (* N *)
O =                 /0x4F/ ;    (* O *)
P =                 /0x50/ ;    (* P *)
Q =                 /0x51/ ;    (* Q *)
R =                 /0x52/ ;    (* R *)
S =                 /0x53/ ;    (* S *)
T =                 /0x54/ ;    (* T *)
U =                 /0x55/ ;    (* U *)
V =                 /0x56/ ;    (* V *)
W =                 /0x57/ ;    (* W *)
X =                 /0x58/ ;    (* X *)
Y =                 /0x59/ ;    (* Y *)
Z =                 /0x5A/ ;    (* Z *)
open-bracket =      /0x5B/ ;    (* [ *)
back-slash =        /0x5C/ ;    (* \ *)
close-bracket =     /0x5D/ ;    (* ] *)
carat =             /0x5E/ ;    (* ^ *)
underscore =        /0x5F/ ;    (* _ *)
back-quote =        /0x60/ ;    (* ` *)
a =                 /0x61/ ;    (* a *)
b =                 /0x62/ ;    (* b *)
c =                 /0x63/ ;    (* c *)
d =                 /0x64/ ;    (* d *)
e =                 /0x65/ ;    (* e *)
f =                 /0x66/ ;    (* f *)
g =                 /0x67/ ;    (* g *)
h =                 /0x68/ ;    (* h *)
i =                 /0x69/ ;    (* i *)
j =                 /0x6A/ ;    (* j *)
k =                 /0x6B/ ;    (* k *)
l =                 /0x6C/ ;    (* l *)
m =                 /0x6D/ ;    (* m *)
n =                 /0x6E/ ;    (* n *)
o =                 /0x6F/ ;    (* o *)
p =                 /0x70/ ;    (* p *)
q =                 /0x71/ ;    (* q *)
r =                 /0x72/ ;    (* r *)
s =                 /0x73/ ;    (* s *)
t =                 /0x74/ ;    (* t *)
u =                 /0x75/ ;    (* u *)
v =                 /0x76/ ;    (* v *)
w =                 /0x77/ ;    (* w *)
x =                 /0x78/ ;    (* x *)
y =                 /0x79/ ;    (* y *)
z =                 /0x7A/ ;    (* z *)
open-brace =        /0x7B/ ;    (* { *)
bar =               /0x7C/ ;    (* | *)
close-brace =       /0x7D/ ;    (* } *)
tilde =             /0x7E/ ;    (* ~ *)
del =               /0x7F/ ;    (* DEL *)

                      (*                   *)
                      (* Character Classes *)
                      (*                   *)

control-character = nul | soh | stx | etx | eot | enq | ack | bel | bs
                  | so | si | dle | dc1 | dc2 | dc3 | dc4 | nak | syn
                  | etb | can | em | sub | esc | fs | gs | rs | us
                  | del ;

upper-case-letter = A | B | C | D | E | F | G | H | I | J | K | L | M
                  | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
                  ;

lower-case-letter = a | b | c | d | e | f | g | h | i | j | k | l | m
                  | n | o | p | q | r | s | t | u | v | w | x | y | z
                  ;

letter = upper-case-letter | lower-case-letter ;

binary-digit = zero | one ;

octal-digit = zero | one | two | three | four | five | six | seven ;

decimal-digit = zero | one | two | three | four
              | five | six | seven | eight | nine ;

hexadecimal-digit = zero | one | two | three | four
                  | five | six | seven | eight | nine
                  | A | B | C | D | E | F
                  | a | b | c | d | e | f ;

white-space = space | ht | lf | vt | ff | cr ;

word-first-char = letter | underscore ;

word-next-char = decimal-digit | word-first-char ;

word = word-first-char + word-next-char{0,*} ;

assignment-word = word + equal ;

name = word ; (* is this right, or is word more inclusive than name? *)

newline = lf ; (* can this also include cr, vt, etc *)

io-number = decimal-digits{1,*} + greater-than ;

and-if-symbol = ampersand + ampersand ;  (* && *)

or-if-symbol = bar + bar ;  (* || *)

double-semicolon-symbol = semicolon + semicolon ;  (* ;; *)

double-less-than-symbol = less-than + less-than ;  (* << *)

double-greater-than-symbol = greater-than + greater-than ;  (* >> *)

less-than-and-symbol = less-than + ampersand ;  (* <& *)

greater-than-and-symbol = greater-than + ampersand ;  (* >& *)

less-than-greater-than-symbol = less-than | greater-than ;  (* <> *)

double-less-than-dash-symbol = double-less-than-symbol + hyphen ;  (* <<- *)

clobber-symbol = greater-than + bar ;  (* >| *)

if = 'if' ;

then = 'then' ;

else = 'else' ;

elif = 'elif' ;

fi = 'fi' ;

do = 'do' ;

done = 'done' ;

case = 'case' ;

esac = 'esac' ;

while = 'while' ;

until = 'until' ;

for = 'for' ;

in = 'in' ;

(* Grammar Rules *)

complete-command = list + separator{0,1} ;

list = list-sequence | and-or ;

list-sequence = list + separator-op + and-or ;

and-sequence = and-or + and-if-symbol + linebreak + pipeline ;

or-sequence = and-or + or-if-symbol + linebreak + pipeline ;

and-or : pipeline | and-sequence | or-sequence ;

pipeline = exclamation-point{0,1} + pipe-sequence ;

pipe-sequence = command + pipe_sequence-continuation{0,*} ;

pipe-sequence-continuation = PIPE + linebreak + command ;

command = simple-command
        | compound-command-sequence
        | function-definition
        ;

compound-command-sequence = compound-command + redirect_list{0,1} ;

compound-command = bracegroup
                 | subshell
                 | for-clause
                 | case-clause
                 | if-clause
                 | while-clause
                 | until-clause
                 ;

subshell = LPAREN + compound-list + RPAREN ;

compound-list = newline-list{0,1} + term + separator{0,1} ;

term = term + term-continuation{0,*} ;

term-continuation = separator + and-or ;

for-clause = for + name + linebreak + for-predicate{0,1} + do-group ;

for-predicate = wordlist{0,1} + sequential-sep ;

wordlist = word{1,*} ;

case-clause = case
              + word
              + linebreak
              + in
              + linebreak
              + case-content{0,1}
              + esac
              ;

case-content = case-list | case-list-ns ;

case-list-ns = case-item-ns{1,*} ;

case-list = case-item{1,*} ;

case-item-ns = LPAREN{0,1}
               + pattern
               + RPAREN
               + compound-list{0,1}
               + linebreak
               ;

case-item = LPAREN{0,1}
            + pattern
            + RPAREN
            + case-item-content
            + double-semicolon-symbol
            + linebreak
            ;

case-item-content = linebreak | compound-list ;

pattern = word + pattern-continuation{0,*} ;

pattern-continuation = PIPE + word ;

if-clause = if
            + compound-list
            + then
            + compound-list
            + else-part{0,1}
            + fi ;

else-part = else-part-list | else-part-sequence-2 ;

else-part-list = else-part-sequence-4{1,*} ;

else-part-sequence-4 = elif + compound-list + then + compound-list ;

else-part-sequence-2 = else + compound-list ;

while-clause = while + compound-list + do-group ;

until-clause = until + compound-list + do-group ;

function-definition = fname + LPAREN + RPAREN + linebreak + function-body ;

function-body = compound-command + redirect-list{0,1} ;

fname = NAME ;

brace-group = open-brace + compound-list + close-brace ;

do-group = do + compound-list + done ;

simple-command = cmd-word-sequence-3
               | cmd-word-sequence-2
               | cmd-word-sequence-1
               | cmd-name-sequence-2
               | cmd-name-sequence-1
               ;

cmd-word-sequence-3 = cmd-prefix + cmd-word + cmd-suffix ;

cmd-word-sequence-2 = cmd-prefix + cmd-word ;

cmd-word-sequence-1 = cmd-prefix ;

cmd-name-sequence-2 = cmd-name + cmd-suffix ;

cmd-name-sequence-1 = cmd-name ;

cmd-name = word ;

cmd-word = word ;

cmd-prefix = cmd-prefix-item{1,*} ;

cmd-prefix-item = io-redirect | ASSIGNMENT-word ;

cmd-suffix = cmd-suffix-item{1,*} ;

cmd-suffix-item = io-redirect | word ;

redirect-list = io-redirect{1,*} ;

io-redirect = io-file | io-file-fd | io-here | io-here-fd ;

io-file-fd = io-number + io-file ;

io-here-fd = io-number + io-here ;

io-file = less-than
        | less-than-and-symbol
        | greater-than
        | greater-than-and-symbol
        | double-greater-than-symbol
        | less-than-greater-than-symbol
        | clobber-symbol
        ;

filename = word ;

io-here = io-here-dless | io-here-dlessdash ;

io-here-dless = double-less-than-symbol + here-end ;

io-here-dless-dash = double-less-than-dash-symbol + here-end ;

here-end = word ;

newline-list = newline{1,*} ;

linebreak = newline-list{0,1} ;

separator-op = ampersand | semicolon ;

command-end = separator-op + linebreak ;

separator = command-end | newline-list ;

line-end = semicolon + linebreak ;

sequential-sep = line-end | newline-list ;
